import Mathlib.Order.CompletePartialOrder
import Mathlib.Analysis.InnerProductSpace.Basic
import Mathlib.MeasureTheory.Integral.Bochner
import Mathlib
import Polya.MiscLemmas

open MeasureTheory Topology Filter ENNReal NNReal BigOperators

section Grid

/-- The integer grid in `d` dimensions. -/
abbrev Grid d := Fin d ‚Üí ‚Ñ§

/-- The integer grid in `d` dimensions is countable. -/
lemma Grid.countable (d : ‚Ñï) : Countable (Grid d) := instCountableForallOfFinite

end Grid

section WalkOfSteps

variable {d : ‚Ñï}

/-- Walk on the grid with a given step sequence `steps`. -/
def walkOfSteps (steps : (t : ‚Ñï) ‚Üí Grid d) (t : ‚Ñï) : Grid d :=
  ‚àë s in Finset.range t, steps s

end WalkOfSteps

#eval walkOfSteps (fun _t => fun (d : Fin 2) => (if d = 0 then 1 else 0)) 4
#check ![0, 4]

section RandomWalkOfSteps

variable {Œ© : Type*} [MeasurableSpace Œ©] (P : Measure Œ©) [IsProbabilityMeasure P]
variable {d : ‚Ñï}

/-- Random walk with a given random step sequence `Œæ`. -/
def RW (Œæ : (t : ‚Ñï) ‚Üí Œ© ‚Üí Grid d) (t : ‚Ñï) (œâ : Œ©) : Grid d :=
  walkOfSteps (fun s ‚Ü¶ Œæ s œâ) t

/-- Another equivalent definition with non-fixed `œâ : Œ©` -/
def RW_def : RW = fun (Œæ : (t : ‚Ñï) ‚Üí Œ© ‚Üí Grid d) (t : ‚Ñï) (œâ : Œ©) ‚Ü¶ walkOfSteps (fun s ‚Ü¶ Œæ s œâ) t := by rfl

-- h : Eq (A -> B)
-- ‚àÄ A, h : Eq (B)

-- example (f g : A ‚Üí B) : (h : f = g) ‚Üî
-- #check Function.funext_iff.mp RW_def'

/-- The position of a random walk is a random variable (measurable) if the steps are random
variables (measurable). -/
lemma RW.measurable {Œæ : (t : ‚Ñï) ‚Üí Œ© ‚Üí Grid d} (Œæ_mble : ‚àÄ t, Measurable (Œæ t)) (t : ‚Ñï) :
    Measurable (RW Œæ t) := by
-- Doable with `measurable_const` and `Finset.sum_range_succ` and `Measurable.add`.
-- Note: `measurable_add` is not so convenient here! (It is more general, though.)
  induction t with
  | zero => exact measurable_const
  | succ t ih =>
    simp_rw [RW_def, walkOfSteps, Finset.sum_range_succ]
    exact ih.add (Œæ_mble t)

end RandomWalkOfSteps

noncomputable section RegularizedOccupation

variable {Œ© : Type*} [MeasurableSpace Œ©] (P : Measure Œ©) [IsProbabilityMeasure P]
variable {d : ‚Ñï}

/-- Regularized occupation of a given walk. -/
def walkRegularizedOccupation (walk : (t : ‚Ñï) ‚Üí Grid d) (r : ‚Ñù‚â•0‚àû) (x : Grid d) :=
  ‚àë' t, Set.indicator {x} (fun _ ‚Ü¶ r ^ t) (walk t)

lemma ENNReal.pow_le_pow_left : ‚àÄ {a b : ‚Ñù‚â•0‚àû}, a ‚â§ b ‚Üí ‚àÄ {n : ‚Ñï}, a ^ n ‚â§  b ^ n :=
  fun h n ‚Ü¶ pow_le_pow_left' h n

/-- Regularized occupation of a walk at any point is an increasing (more precisely nondecreasing)
function of the regularization parameter `r`. -/
lemma walkRegularizedOccupation_apply_mono (walk : (t : ‚Ñï) ‚Üí Grid d) (x : Grid d) :
    Monotone (fun r ‚Ü¶ walkRegularizedOccupation walk r x) := by
  intro r1 r2 hr
  -- rw [MeasureTheory.Measure.tsum_indicator_apply_singleton (s := {x})]
  apply tsum_mono
  repeat exact ENNReal.summable
  rw [Pi.le_def]
  intro n
  by_cases h : walk n = x
  ¬∑ rw [‚Üê Set.mem_singleton_iff] at h
    rw [h]
    simp only [Set.mem_singleton_iff, Set.indicator_of_mem]
    exact ENNReal.pow_le_pow_left hr
  ¬∑ simp [h]

/-- Regularized occupation of a walk is an increasing (more precisely nondecreasing) function
of the regularization parameter `r`. -/
lemma walkRegularizedOccupation_mono (walk : (t : ‚Ñï) ‚Üí Grid d) :
    Monotone (fun r ‚Ü¶ walkRegularizedOccupation walk r) := by
  intro r1 r2 hr
  rw [Pi.le_def]
  exact fun _ ‚Ü¶ walkRegularizedOccupation_apply_mono _ _ hr

/-- Regularized occupation of any walk with regularization `r` is at most `(1-r)‚Åª¬π`. -/
lemma walkRegularizedOccupation_le (walk : (t : ‚Ñï) ‚Üí Grid d) (r : ‚Ñù‚â•0‚àû) (x : Grid d) :
    walkRegularizedOccupation walk r x ‚â§ (1 - r)‚Åª¬π := by
  rw [‚Üê tsum_geometric]
  apply tsum_le_tsum
  ¬∑ intro t
    by_cases h : walk t = x <;>
      simp [h]
  ¬∑ exact ENNReal.summable
  ¬∑ exact ENNReal.summable

-- Remark by Kalle: It is "funny" (and convenient) that here we do not need to assume `r<1`,
-- which is usually needed for the convergence of the geometric series. That is because in `‚Ñù‚â•0‚àû`
-- we have `1/‚àû = 0` according to Lean's (or rather Mathlib's) definition.

/-- Regularized occupation `L_Œª` of a random walk. -/
def regularizedOccupation (X : (t : ‚Ñï) ‚Üí Œ© ‚Üí Grid d) (r : ‚Ñù‚â•0‚àû) (x : Grid d) (œâ : Œ©) :=
  walkRegularizedOccupation (fun t ‚Ü¶ X t œâ) r x

/-- A rewrite lemma for the regularized occupation `L_Œª` of a random walk. -/
lemma regularizedOccupation_eq (X : (t : ‚Ñï) ‚Üí Œ© ‚Üí Grid d) (r : ‚Ñù‚â•0‚àû) (x : Grid d) :
    regularizedOccupation X r x = fun œâ ‚Ü¶ ‚àë' t, Set.indicator ((X t) ‚Åª¬π' {x}) (fun _ ‚Ü¶ r ^ t) œâ :=
  rfl

/-- Regularized occupation of a random walk at any point is increasing (more precisely nondecreasing)
in the regularization parameter `r`. -/
lemma regularizedOccupation_apply_mono (X : (t : ‚Ñï) ‚Üí Œ© ‚Üí Grid d) (x : Grid d) :
    Monotone (fun r ‚Ü¶ regularizedOccupation X r x) := by
  intro r1 r2 hr
  rw [Pi.le_def]
  exact fun _ ‚Ü¶ walkRegularizedOccupation_mono _ hr _

/-- Regularized occupation of a random walk is increasing (more precisely nondecreasing) in the
regularization parameter `r`. -/
lemma regularizedOccupation_mono (X : (t : ‚Ñï) ‚Üí Œ© ‚Üí Grid d) :
    Monotone (fun r ‚Ü¶ regularizedOccupation X r) := by
  intro r1 r2 hr
  rw [Pi.le_def]
  exact fun _ _ ‚Ü¶ regularizedOccupation_apply_mono _ _ hr _

/-- Regularized occupation of a random walk at any point is left continuous in the
regularization parameter `r`. -/
lemma regularizedOccupation_apply_tendsto_of_monotone (X : (t : ‚Ñï) ‚Üí Œ© ‚Üí Grid d)
    {rs : ‚Ñï ‚Üí ‚Ñù‚â•0‚àû} {r : ‚Ñù‚â•0‚àû} (rs_incr : Monotone rs) (rs_lim : Tendsto rs atTop (ùìù[<] r)) (x : Grid d) :
    Tendsto (fun n ‚Ü¶ regularizedOccupation X (rs n) x) atTop (ùìù (regularizedOccupation X r x)) := by
  simp_rw [regularizedOccupation_eq, ‚Üê lintegral_count]

  rw [tendsto_pi_nhds]
  intro œâ
  apply lintegral_tendsto_of_tendsto_of_monotone
  ¬∑ exact fun _ ‚Ü¶ Measurable.aemeasurable fun ‚¶Ét‚¶Ñ _a ‚Ü¶ trivial
  ¬∑ rw [Monotone] at rs_incr
    apply Filter.eventually_of_forall
    intro n a b hab
    apply Set.indicator_le_indicator
    exact ENNReal.pow_le_pow_left (rs_incr hab)
  ¬∑ apply Filter.eventually_of_forall
    intro n
    by_cases h : œâ ‚àà X n ‚Åª¬π' {x}
    ¬∑ simp [h]
      -- There should be a more general solution than ENNReal.Tendsto.pow
      apply ENNReal.Tendsto.pow
      intro S h
      rw [Tendsto, Filter.le_def] at rs_lim
      exact rs_lim _ (mem_nhdsWithin_of_mem_nhds h)
    ¬∑ simp [h]

-- This can almost be proven with the Monotone Convergence Theorem
-- `lintegral_tendsto_of_tendsto_of_monotone`, once one writes the infinite sum as an integral
-- with respect to counting measure using `lintegral_count`.
-- One also needs `tendsto_pi_nhds` (characterization of pointwise convergence).
-- Later we might want to generalize this, since the monotonicity hypothesis is
-- in fact unnecessary (but getting rid of it requires some filter stuff).

/-- The regularized occupation of a random walk is a random variable (measurable). -/
lemma regularizedOccupation.measurable
    {X : (t : ‚Ñï) ‚Üí Œ© ‚Üí Grid d} (X_mble : ‚àÄ t, Measurable (X t)) (r : ‚Ñù‚â•0‚àû) (x : Grid d) :
    Measurable (regularizedOccupation X r x) :=
  Measurable.ennreal_tsum (fun t ‚Ü¶ Measurable.ite
    (measurableSet_eq_fun (X_mble t) measurable_const) measurable_const measurable_const)

/-- Regularized occupation of any random walk with regularization `r` is at most `(1-r)‚Åª¬π`. -/
lemma regularizedOccupation_le (X : (t : ‚Ñï) ‚Üí Œ© ‚Üí Grid d) (r : ‚Ñù‚â•0‚àû) (x : Grid d) :
    regularizedOccupation X r x ‚â§ fun _ ‚Ü¶ (1 - r)‚Åª¬π := by
  rw [‚Üê tsum_geometric, Pi.le_def]
  intro œâ
  apply tsum_le_tsum
  intro n
  by_cases h : X n œâ = x <;> simp [h]
  ¬∑ exact ENNReal.summable
  ¬∑ exact ENNReal.summable

lemma walkRegularizedOccupation_lt_top (X : (t : ‚Ñï) ‚Üí Grid d)
    {r : ‚Ñù‚â•0‚àû} (r_lt_one : r < 1) (x : Grid d) :
    walkRegularizedOccupation X r x < ‚àû := by
  rw [walkRegularizedOccupation]
  have gona :  ‚àë' (t : ‚Ñï), (Set.singleton x).indicator (fun _x ‚Ü¶ r ^ t) (X t) ‚â§  ‚àë' (t : ‚Ñï), (fun _x ‚Ü¶ r ^ t) (X t) := by
    apply tsum_le_tsum
    intro n
    rw [Set.indicator]
    by_cases h : X n ‚àà Set.singleton x
    simp [h]
    simp [h]
    simp
    simp
  have : ‚àë' (t : ‚Ñï), (fun _x ‚Ü¶ r ^ t) (X t) < ‚ä§ := by
    rw [tsum_geometric]
    norm_num
    exact r_lt_one
  exact lt_of_le_of_lt gona this
/-- Regularized occupation of a random walk is finite if the regularization satisfies `r<1`. -/

-- TODO : use walkRegularizedOccupation_lt_top for regularizedOccupation_lt_top

lemma regularizedOccupation_lt_top (X : (t : ‚Ñï) ‚Üí Œ© ‚Üí Grid d)
    {r : ‚Ñù‚â•0‚àû} (r_lt_one : r < 1) (x : Grid d) (œâ : Œ©) :
    regularizedOccupation X r x œâ < ‚àû := by
  rw [regularizedOccupation, walkRegularizedOccupation]
  have gona :  ‚àë' (t : ‚Ñï), (Set.singleton x).indicator (fun _x ‚Ü¶ r ^ t) (X t œâ) ‚â§  ‚àë' (t : ‚Ñï), (fun _x ‚Ü¶ r ^ t) (X t œâ) := by
    apply tsum_le_tsum
    ¬∑ intro n
      rw [Set.indicator]
      by_cases h : X n œâ ‚àà Set.singleton x
      ¬∑ simp [h]
      ¬∑ simp [h]
    ¬∑ exact ENNReal.summable
    ¬∑ exact ENNReal.summable
  have : ‚àë' (t : ‚Ñï), (fun _x ‚Ü¶ r ^ t) (X t œâ) < ‚ä§ := by
    rw [tsum_geometric]
    norm_num
    exact r_lt_one
  exact lt_of_le_of_lt gona this

/-- The sum over possible values of constant indicators of singletons is the constant. -/
lemma tsum_indicator_singleton_eq {S : Type*} [DecidableEq S]
    {R : Type*} [AddCommMonoid R] [TopologicalSpace R] (y : S) (c : R) :
    ‚àë' i, Set.indicator {i} (fun _ ‚Ü¶ c) y = c := by
  rw [tsum_eq_single]
  ¬∑ exact if_pos rfl
  ¬∑ exact fun b' a ‚Ü¶ if_neg (id (Ne.symm a))

  -- Kalle says: Maybe this belongs to a "misc lemmas" file rather than here.

/-- A random variable always has some value, so it is easy to calculate the sum over possible values of
the indicators of having that value. -/
lemma tsum_indicator_value_eq {S : Type*} [DecidableEq S]
    {R : Type*} [AddCommMonoid R] [TopologicalSpace R] (Y : Œ© ‚Üí S) (c : R) :
  ‚àë' i, Set.indicator (Y ‚Åª¬π' {i}) (fun _ ‚Ü¶ c) œâ = c := tsum_indicator_singleton_eq _ _

/-- A random walk is always somewhere, so it is easy to calculate the sum over positions
of the indicators of being there. -/
lemma tsum_indicator_walk_position_eq (X : (t : ‚Ñï) ‚Üí Œ© ‚Üí Grid d)
    {R : Type*} [AddCommMonoid R] [TopologicalSpace R] (c : R) :
  ‚àë' x, Set.indicator ((X t) ‚Åª¬π' {x}) (fun _ ‚Ü¶ c) œâ = c := tsum_indicator_singleton_eq _ _

/-- A walk is always somewhere, so it is easy to calculate the sum over positions
of the regularized occupations at those positions. -/
lemma tsum_walkRegularizedOccupation_eq_geom_series (walk : (t : ‚Ñï) ‚Üí Grid d) (r : ‚Ñù‚â•0‚àû) :
    ‚àë' x, walkRegularizedOccupation walk r x = ‚àë' (t : ‚Ñï), r ^ t := by
  simp_rw [walkRegularizedOccupation]
  rw [ENNReal.tsum_comm]
  have le1 : ‚àë' (b : ‚Ñï) (a : Grid d), (Set.singleton a).indicator (fun _x ‚Ü¶ r ^ b) (walk b) ‚â§ ‚àë' (t : ‚Ñï), r ^ t := by
    apply tsum_le_tsum
    intro i
    simp_rw [Set.indicator]
    rw [tsum_eq_single]
    case hf => exact ENNReal.summable
    case b => exact walk i
    case _ => simp [Set.singleton, Set.mem_setOf]
    case _ => exact fun b' a ‚Ü¶ if_neg (id (Ne.symm a))
    case _ => exact ENNReal.summable
  have le2 : ‚àë' (t : ‚Ñï), r ^ t ‚â§ ‚àë' (b : ‚Ñï) (a : Grid d), (Set.singleton a).indicator (fun _x ‚Ü¶ r ^ b) (walk b) := by
    apply tsum_le_tsum
    intro i
    simp [Set.indicator]
    rw [tsum_eq_single]
    case b => exact walk i
    case hf => exact ENNReal.summable
    case _ => simp [Set.singleton, Set.mem_setOf]
    case _ => exact fun b' a ‚Ü¶ if_neg (id (Ne.symm a))
    case _ => exact ENNReal.summable
  exact le_antisymm le1 le2

-- Instead of literal Fubini's theorem (for counting measures), here it is better to use
-- the version `ENNReal.tsum_comm`.

/-- A random walk is always somewhere, so it is easy to calculate the sum over positions
of the regularized occupations at those positions. -/
lemma tsum_regularizedOccupation_eq_geom_series (X : (t : ‚Ñï) ‚Üí Œ© ‚Üí Grid d) (r : ‚Ñù‚â•0‚àû) :
    ‚àë' x, regularizedOccupation X r x = fun _ ‚Ü¶ (‚àë' (t : ‚Ñï), r ^ t):= by
  ext œâ
  rw [tsum_apply]
  apply tsum_walkRegularizedOccupation_eq_geom_series
  rw [Pi.summable]
  exact fun _ ‚Ü¶ ENNReal.summable

/-- A walk is always somewhere, so it is easy to calculate the sum over positions
of the regularized occupations at those positions. -/
lemma tsum_toReal_walkRegularizedOccupation_eq_geom_series (walk : (t : ‚Ñï) ‚Üí Grid d)
    {r : ‚Ñù‚â•0} (r_lt_one : r < 1) :
    ‚àë' x, (walkRegularizedOccupation walk r x).toReal = (‚àë' (t : ‚Ñï), r.toReal ^ t):= by
  rw [‚Üê ENNReal.tsum_toReal_eq, tsum_walkRegularizedOccupation_eq_geom_series]
  ¬∑ exact ENNReal.tsum_toReal_eq (fun _ ‚Ü¶ pow_ne_top coe_ne_top)
  ¬∑ exact fun _ ‚Ü¶ LT.lt.ne (walkRegularizedOccupation_lt_top _ (coe_lt_one_iff.mpr r_lt_one) _)

-- To get to use the standard Fubini's theorem `lintegral_lintegral_swap`, one can first
-- rewrite the sums as integrals (w.r.t. counting measures) with `lintegral_count`.

/-- A random walk is always somewhere, so it is easy to calculate the sum over positions
of the regularized occupations at those positions. -/
lemma tsum_toReal_regularizedOccupation_eq_geom_series (X : (t : ‚Ñï) ‚Üí Œ© ‚Üí Grid d)
    {r : ‚Ñù‚â•0} (r_lt_one : r < 1) (œâ : Œ©) :
    ‚àë' x, (regularizedOccupation X r x œâ).toReal = ‚àë' (t : ‚Ñï), r.toReal ^ t :=
  tsum_toReal_walkRegularizedOccupation_eq_geom_series (fun t ‚Ü¶ X t œâ) r_lt_one
-- This is easy with the previous one!

lemma summable_regularizedOccupation : Summable (regularizedOccupation X r) := by
  rw [Pi.summable]
  exact fun _ ‚Ü¶ ENNReal.summable

/-- A random walk is always somewhere, so it is easy to calculate the sum over positions
of the regularized occupations at those positions. When `r < 1`, the infinite sums are
convergent and the calculation yields an equality in `‚Ñù`. -/
lemma tsum_toReal_regularizedOccupation_eq (X : (t : ‚Ñï) ‚Üí Œ© ‚Üí Grid d)
    {r : ‚Ñù‚â•0} (r_lt_one : r < 1) (œâ : Œ©) :
    ‚àë' x, (regularizedOccupation X r x œâ).toReal = (1 - r)‚Åª¬π := by
  rw [‚Üê tsum_toReal_eq]
  ¬∑ rw [‚Üê tsum_apply, tsum_regularizedOccupation_eq_geom_series]
    ¬∑ rw [tsum_geometric, toReal_inv]; rfl
    ¬∑ exact summable_regularizedOccupation
  ¬∑ exact fun _ ‚Ü¶ LT.lt.ne (regularizedOccupation_lt_top _ (coe_lt_one_iff.mpr r_lt_one) _ _)
-- This is the previous one conbined with a convergent geometric series.

/-- The sum over points of the expected value of the regularized occupation is a
geometric series with the ratio given by the regularization. -/
lemma tsum_lintegral_norm_regularizedOccupation_eq_geom_series
    {X : (t : ‚Ñï) ‚Üí Œ© ‚Üí Grid d} (X_mble : ‚àÄ t, Measurable (X t)) (r : ‚Ñù‚â•0‚àû) :
    ‚àë' x, ‚à´‚Åª œâ, regularizedOccupation X r x œâ ‚àÇP = (‚àë' (t : ‚Ñï), r ^ t):= by
  rw [‚Üê lintegral_tsum]
  conv =>
    enter [1, 2, œâ] -- short for arg 1; arg 2; intro œâ
    -- rw [‚Üê tsum_apply (hf := summable_regularizedOccupation)]
    rw [‚Üê tsum_apply] -- generates a subgoal for hf
    ¬∑ rw [tsum_regularizedOccupation_eq_geom_series]
    ¬∑ exact summable_regularizedOccupation
  ¬∑ simp
  ¬∑ exact fun _ ‚Ü¶ Measurable.aemeasurable (regularizedOccupation.measurable X_mble r _)

-- Here the most appropriate version of "Fubini's theorem" is probably `lintegral_tsum`.
/-- The sum over points of the expected value of the regularized occupation is just `(1-r)‚Åª¬π`. -/
lemma tsum_lintegral_regularizedOccupation_eq
    {X : (t : ‚Ñï) ‚Üí Œ© ‚Üí Grid d} (X_mble : ‚àÄ t, Measurable (X t)) (r : ‚Ñù‚â•0‚àû) :
    ‚àë' x, ‚à´‚Åª œâ, regularizedOccupation X r x œâ ‚àÇP = (1 - r)‚Åª¬π := by
  rw [‚Üê tsum_geometric]
  exact tsum_lintegral_norm_regularizedOccupation_eq_geom_series _ X_mble _

-- Remark by Kalle: Again it is "funny" (and convenient) that here we do not need to assume `r<1`,
-- which is usually needed for the convergence of the geometric series. That is because in `‚Ñù‚â•0‚àû`
-- we have `1/‚àû = 0` according to Lean's (or rather Mathlib's) definition.

/-- The sum over points of the expected norms of the regularized occupation is at most `(1-r)‚Åª¬π`. -/
lemma tsum_lintegral_norm_regularizedOccupation_le
    {X : (t : ‚Ñï) ‚Üí Œ© ‚Üí Grid d} (X_mble : ‚àÄ t, Measurable (X t)) (r : ‚Ñù‚â•0‚àû) :
    ‚àë' x, ‚à´‚Åª œâ, ‚Äñ(regularizedOccupation X r x œâ).toReal‚Äñ.toNNReal ‚àÇP ‚â§ (1 - r)‚Åª¬π := by
  by_cases rge1 : r ‚â• 1
  ¬∑ simp only [rge1, tsub_eq_zero_of_le, ENNReal.inv_zero]
    exact le_top
  simp at rge1
  rw [‚Üê lintegral_tsum]
  ¬∑ have norm_le_lemma : ‚àÄ œâ x, ‚Äñ(regularizedOccupation X r x œâ).toReal‚Äñ.toNNReal ‚â§ (regularizedOccupation X r x œâ).toReal.toNNReal := by
      intros œâ x
      rw [Real.toNNReal_le_toNNReal_iff toReal_nonneg]
      rw [Real.norm_eq_abs]
      rw [abs_eq_self.mpr toReal_nonneg]
    -- have summable : ‚àÄ œâ, Summable (fun x ‚Ü¶ (regularizedOccupation X r x œâ).toReal) := by
    --   intro œâ
    --   apply ENNReal.summable_toReal
    --   rw [‚Üê tsum_apply, tsum_regularizedOccupation_eq_geom_series, tsum_geometric]
    --   apply LT.lt.ne
    --   simp

    have : ‚à´‚Åª (œâ : Œ©), ‚àë' (i : Grid d), (regularizedOccupation X r i œâ).toReal.toNNReal ‚àÇP ‚â§ (1 - r)‚Åª¬π := by
      have summable_toReal_toNNReal (œâ : Œ©) : Summable (fun i ‚Ü¶ (regularizedOccupation X r i œâ).toReal.toNNReal) := by
        rw [‚Üê tsum_coe_ne_top_iff_summable]
        rw [‚Üê ENNReal.coe_tsum (by
          -- TODO refactor this proof (used multiple times)
          apply Summable.toNNReal
          apply ENNReal.summable_toReal
          apply LT.lt.ne
          rw [‚Üê tsum_apply, tsum_regularizedOccupation_eq_geom_series, tsum_geometric]
          simp
          exact rge1
          ¬∑ rw [Pi.summable]
            intro o
            exact ENNReal.summable
          )]
        simp only [toNNReal_toReal_eq, ne_eq, coe_ne_top, not_false_eq_true]
      conv in tsum _ =>
        rw [‚Üê ENNReal.coe_tsum (summable_toReal_toNNReal œâ)]
      -- simp_rw [Real.toNNReal_coe]
      conv in tsum _ =>
        enter [1, a]
        -- rw [Real.toNNReal]
        simp
      have regularizedOccupation_lt_top' (œâ : Œ©) : ‚àÄ (a : Grid d), regularizedOccupation X r a œâ ‚â† ‚ä§ := by
        intro x
        apply LT.lt.ne
        apply regularizedOccupation_lt_top
        exact rge1
      conv in tsum _ =>
        rw [‚Üê ENNReal.tsum_toNNReal_eq (regularizedOccupation_lt_top' œâ)]
        rw [‚Üê tsum_apply summable_regularizedOccupation]
      simp_rw [tsum_regularizedOccupation_eq_geom_series]
      rw [tsum_geometric, lintegral_const, measure_univ, mul_one]
      exact coe_toNNReal_le_self

    apply le_trans _ this
    have lemma2 œâ : ‚àë' x, ‚Äñ(regularizedOccupation X r x œâ).toReal‚Äñ.toNNReal ‚â§ ‚àë' x,(regularizedOccupation X r x œâ).toReal.toNNReal := by
      apply tsum_le_tsum (norm_le_lemma œâ)
      ¬∑ apply Summable.toNNReal
        simp_rw [Real.norm_eq_abs, abs_toReal]
        apply ENNReal.summable_toReal
        apply LT.lt.ne
        rw [‚Üê tsum_apply, tsum_regularizedOccupation_eq_geom_series, tsum_geometric]
        simp
        exact rge1
        ¬∑ rw [Pi.summable]
          intro o
          exact ENNReal.summable
      ¬∑ apply Summable.toNNReal
        apply ENNReal.summable_toReal
        apply LT.lt.ne
        rw [‚Üê tsum_apply, tsum_regularizedOccupation_eq_geom_series, tsum_geometric]
        simp
        exact rge1
        ¬∑ rw [Pi.summable]
          intro o
          exact ENNReal.summable

    -- simp_rw [‚Üê ENNReal.coe_tsum (by
    --   sorry
    -- )]

    conv =>
      arg 1
      arg 2
      intro œâ
      rw [‚Üê ENNReal.coe_tsum (by
      apply Summable.toNNReal
      simp_rw [Real.norm_eq_abs, abs_toReal]
      apply ENNReal.summable_toReal
      apply LT.lt.ne
      rw [‚Üê tsum_apply, tsum_regularizedOccupation_eq_geom_series, tsum_geometric]
      simp only [inv_lt_top, tsub_pos_iff_lt]
      ¬∑ exact rge1
      ¬∑ rw [Pi.summable]; exact fun _ ‚Ü¶ ENNReal.summable
      )]

    conv =>
      arg 2
      arg 2
      intro œâ
      rw [‚Üê ENNReal.coe_tsum (by
      apply Summable.toNNReal
      apply ENNReal.summable_toReal
      apply LT.lt.ne
      rw [‚Üê tsum_apply, tsum_regularizedOccupation_eq_geom_series, tsum_geometric,
        inv_lt_top, tsub_pos_iff_lt]
      ¬∑ exact rge1
      ¬∑ rw [Pi.summable]; exact fun _ ‚Ü¶ ENNReal.summable
      )]

    apply lintegral_mono
    rw [Pi.le_def]
    intro œâ
    rw [ENNReal.coe_le_coe]
    exact lemma2 œâ
  ¬∑ refine fun _ ‚Ü¶  Measurable.aemeasurable ?_
    simp only [Real.norm_eq_abs, abs_toReal, toNNReal_toReal_eq, measurable_coe_nnreal_ennreal_iff]
    exact Measurable.ennreal_toNNReal (regularizedOccupation.measurable X_mble r _)

-- Some of the earlier tricks apply again.

end RegularizedOccupation

noncomputable section RegularizedGreensFunction

variable {Œ© : Type*} [MeasurableSpace Œ©] (P : Measure Œ©) [IsProbabilityMeasure P]
variable {d : ‚Ñï}

/-- The regularized Green's function of a random walk. -/
def regularizedG (X : (t : ‚Ñï) ‚Üí Œ© ‚Üí Grid d) (r : ‚Ñù‚â•0‚àû) (x : Grid d) : ‚Ñù :=
  ‚à´ œâ, ENNReal.toReal (regularizedOccupation X r x œâ) ‚àÇP

/-- An auxiliary step: one can interchange a sum and expected value for `regularizedG` summed over
all grid points. -/
lemma tsum_regularizedG_eq_lintegral_tsum {X : (t : ‚Ñï) ‚Üí Œ© ‚Üí Grid d}
    {r : ‚Ñù‚â•0}
    (r_lt_one : r < 1)
    (X_mble : ‚àÄ t, Measurable (X t)) :
    ‚àë' x, regularizedG P X r x
      = (‚à´ œâ, ‚àë' x, ‚àë' t,
    Set.indicator ((X t) ‚Åª¬π' {x}) (fun _ ‚Ü¶ (r : ‚Ñù) ^ t) œâ ‚àÇP) := by

  simp_rw [regularizedG, Set.indicator, regularizedOccupation, walkRegularizedOccupation, Set.indicator]
  rw [integral_tsum]
  -- simp_rw [Set.mem_singleton_iff]
  -- have (x) (œâ) : ‚àÄ (a : ‚Ñï), (if X a œâ = x then (‚Üër : ‚Ñù‚â•0‚àû) ^ a else 0) ‚â† ‚àû := by
  conv =>
    enter [1, 1, x, 2, œâ]
    rw [ENNReal.tsum_toReal_eq (by
      intro a
      by_cases h : X a œâ = x
      ¬∑ simp [h]
      ¬∑ simp [h]
    )]
    simp [apply_ite]
  simp only [Set.mem_preimage, Set.mem_singleton_iff]
  ¬∑ intro x
    apply Measurable.aestronglyMeasurable

    have : Measurable $ fun (œâ : Œ©) ‚Ü¶ ‚àë' (t : ‚Ñï), Set.indicator ((X t) ‚Åª¬π' {x}) (fun _ ‚Ü¶ (r : ‚Ñù‚â•0‚àû) ^ t) œâ := by
      apply regularizedOccupation.measurable X_mble

    have := Measurable.coe_nnreal_real (Measurable.ennreal_toNNReal this)
    convert this
    rename_i œâ

    rw [ENNReal.tsum_toNNReal_eq (by
      intro n
      rw [Set.indicator]
      by_cases h : œâ ‚àà X n ‚Åª¬π' {x}
      ¬∑ simp [h]
      ¬∑ simp [h]
    )]
    simp_rw [NNReal.coe_tsum]
    simp_rw [Set.indicator]
    simp_rw [apply_ite]
    simp only [Set.mem_preimage, Set.mem_singleton_iff, toNNReal_pow, toNNReal_coe, NNReal.coe_pow,
      zero_toNNReal, NNReal.coe_zero]
  ¬∑ rw [‚Üê lintegral_tsum]
    sorry
    sorry

-- Kalle says: I changed the phrasing slightly for convenience.
-- Instead of literal Fubini's theorem (for counting measure and expected value), here it is
-- better to use the version `integral_tsum`.

-- Lemma 4.14
lemma tsum_regularizedG_eq_lintegral_tsum' {X : (t : ‚Ñï) ‚Üí Œ© ‚Üí Grid d}
    {r : ‚Ñù‚â•0} (r_lt_one : r < 1) (X_mble : ‚àÄ t, Measurable (X t)) :
    ‚àë' x, regularizedG P X r x
      = (‚à´ œâ, ‚àë' x, (regularizedOccupation X r x œâ).toReal ‚àÇP) := by
  conv =>
    arg 1
    arg 1
    intro x
    rw [regularizedG]
  rw [integral_tsum]
  intro x
  apply Measurable.aestronglyMeasurable
  apply Measurable.ennreal_toReal
  exact regularizedOccupation.measurable X_mble (‚Üër) x
  -- apply LT.lt.ne
  -- apply ENNReal.lt_top_of_tsum_ne_top
-- tsum_lintegral_norm_regularizedOccupation_le
  sorry

/-- A summability criterion for a slightly generalized version of walk occupations. -/
lemma summable_weighted_occupation {walk : (t : ‚Ñï) ‚Üí Grid d}
    {g : ‚Ñï ‚Üí ‚Ñù} (g_abssummable : ‚àë' t, ENNReal.ofReal |g t| ‚â† ‚àû) :
    Summable
      (Function.uncurry fun (t : ‚Ñï) (x : Grid d) ‚Ü¶ Set.indicator {x} (fun _‚Ü¶ g t) (walk t)) := by
-- Kalle says: Probably the cleanest way to do this would be to generalize this further.
-- But for now, this seems ok. If you like, thinking about the right generalization can
-- nevertheless be very useful!
-- At least the general helper lemma `summable_of_abs_le_of_tsum_ne_top` can be used here.
-- The earlier tricks (Fubini variants and juggling between sums and integrals w.r.t
-- counting measures) can also come in handy.
  sorry

/-- A summability criterion for (basically) regularized walk occupations. -/
lemma summable_regularized_occupation {walk : (t : ‚Ñï) ‚Üí Grid d} {r : ‚Ñù‚â•0} (r_lt_one : r < 1) :
    Summable (Function.uncurry fun (t : ‚Ñï) (x : Grid d) ‚Ü¶ Set.indicator {x} (fun _ ‚Ü¶ (r : ‚Ñù) ^ t) (walk t)) := by
-- The idea is to get this from the slightly generalized version `summable_weighted_occupation`.
  sorry

lemma tsum_regularizedG_eq {X : (t : ‚Ñï) ‚Üí Œ© ‚Üí Grid d}
    {r : ‚Ñù‚â•0} (r_lt_one : r < 1) (X_mble : ‚àÄ t, Measurable (X t)) :
    ‚àë' x, regularizedG P X r x = (1 - r)‚Åª¬π := by
-- Tada! The first line of equalities of the main proof will be completed here!
  sorry

end RegularizedGreensFunction
